name: Backup Sync (Daily)

on:
  schedule:
    # Once daily at midnight UTC
    - cron: "0 0 * * *"
  # Also trigger after any production deploy succeeds
  workflow_run:
    workflows:
      - "Deploy Homeal API to Azure"
      - "Deploy Homeal Admin Panel to Azure"
      - "Deploy Homeal Super Admin to Azure"
      - "Deploy Homeal Customer Web to Azure"
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      sync_db:
        description: "Sync database"
        type: boolean
        default: true
      sync_apps:
        description: "Sync app deployments"
        type: boolean
        default: true
      force:
        description: "Force sync even if no changes detected"
        type: boolean
        default: false

env:
  RESOURCE_GROUP: rg-visualstudio-lab-mana
  MYSQL_HOST: restrovision-mysql.mysql.database.azure.com
  MYSQL_USER: restrovision_admin
  PROD_DB: homeal_db
  BACKUP_DB: homeal_db_backup

jobs:
  sync-database:
    name: Sync Production DB → Backup DB
    runs-on: ubuntu-latest
    # Run on schedule, manual trigger, or after a successful deploy
    if: >-
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.sync_db == 'true') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Install MySQL client
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq mysql-client > /dev/null 2>&1
          echo "MySQL client installed: $(mysql --version)"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Add GitHub runner IP to MySQL firewall
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Runner IP: $RUNNER_IP"
          az mysql flexible-server firewall-rule create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name restrovision-mysql \
            --rule-name github-actions-runner \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP 2>/dev/null || \
          az mysql flexible-server firewall-rule update \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name restrovision-mysql \
            --rule-name github-actions-runner \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP 2>/dev/null || true
          echo "Waiting 15s for firewall rule to propagate..."
          sleep 15

      - name: Test MySQL connection
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          for i in 1 2 3; do
            echo "Connection attempt $i/3..."
            if mysql \
              --host=${{ env.MYSQL_HOST }} \
              --user=${{ env.MYSQL_USER }} \
              --ssl-mode=REQUIRED \
              --connect-timeout=10 \
              -e "SELECT 'Connection OK' AS status;" 2>&1; then
              echo "Connected successfully"
              exit 0
            fi
            echo "Attempt $i failed, retrying in 10s..."
            sleep 10
          done
          echo "::error::All 3 MySQL connection attempts failed"
          exit 1

      - name: Check for changes between production and backup
        id: check_changes
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          FORCE="${{ github.event.inputs.force || 'false' }}"
          if [ "$FORCE" = "true" ]; then
            echo "Force sync requested, skipping change detection"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # If triggered by a deploy workflow, always sync
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by deployment (${{ github.event.workflow_run.name }}), syncing"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Comparing production and backup databases..."
          MYSQL_OPTS="--host=${{ env.MYSQL_HOST }} --user=${{ env.MYSQL_USER }} --ssl-mode=REQUIRED -N"

          # Compare total row counts across all tables
          PROD_ROWS=$(mysql $MYSQL_OPTS -e "
            SELECT COALESCE(SUM(TABLE_ROWS), 0)
            FROM information_schema.tables
            WHERE table_schema='${{ env.PROD_DB }}' AND table_type='BASE TABLE'
          " 2>/dev/null | tr -d '[:space:]')

          BACKUP_ROWS=$(mysql $MYSQL_OPTS -e "
            SELECT COALESCE(SUM(TABLE_ROWS), 0)
            FROM information_schema.tables
            WHERE table_schema='${{ env.BACKUP_DB }}' AND table_type='BASE TABLE'
          " 2>/dev/null | tr -d '[:space:]')

          # Compare table counts
          PROD_TABLES=$(mysql $MYSQL_OPTS -e "
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema='${{ env.PROD_DB }}' AND table_type='BASE TABLE'
          " 2>/dev/null | tr -d '[:space:]')

          BACKUP_TABLES=$(mysql $MYSQL_OPTS -e "
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema='${{ env.BACKUP_DB }}' AND table_type='BASE TABLE'
          " 2>/dev/null | tr -d '[:space:]')

          echo "Production: $PROD_TABLES tables, ~$PROD_ROWS rows"
          echo "Backup:     $BACKUP_TABLES tables, ~$BACKUP_ROWS rows"

          if [ "$PROD_TABLES" != "$BACKUP_TABLES" ] || [ "$PROD_ROWS" != "$BACKUP_ROWS" ]; then
            echo "Changes detected — will sync"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "No changes detected — skipping sync"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Dump production database
        if: steps.check_changes.outputs.has_changes == 'true'
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          echo "Starting mysqldump of ${{ env.PROD_DB }}..."
          mysqldump \
            --host=${{ env.MYSQL_HOST }} \
            --user=${{ env.MYSQL_USER }} \
            --ssl-mode=REQUIRED \
            --single-transaction \
            --routines \
            --triggers \
            --set-gtid-purged=OFF \
            ${{ env.PROD_DB }} > prod_dump.sql
          echo "Dump size: $(du -h prod_dump.sql | cut -f1)"
          echo "Dump completed at $(date -u)"

      - name: Restore to backup database
        if: steps.check_changes.outputs.has_changes == 'true'
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          echo "Restoring to ${{ env.BACKUP_DB }}..."
          mysql \
            --host=${{ env.MYSQL_HOST }} \
            --user=${{ env.MYSQL_USER }} \
            --ssl-mode=REQUIRED \
            ${{ env.BACKUP_DB }} < prod_dump.sql
          echo "Database sync completed at $(date -u)"

      - name: Verify backup
        if: steps.check_changes.outputs.has_changes == 'true'
        env:
          MYSQL_PWD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          MYSQL_OPTS="--host=${{ env.MYSQL_HOST }} --user=${{ env.MYSQL_USER }} --ssl-mode=REQUIRED -N"
          PROD_TABLES=$(mysql $MYSQL_OPTS -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${{ env.PROD_DB }}'")
          BACKUP_TABLES=$(mysql $MYSQL_OPTS -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${{ env.BACKUP_DB }}'")
          echo "Production tables: $PROD_TABLES"
          echo "Backup tables: $BACKUP_TABLES"
          if [ "$PROD_TABLES" != "$BACKUP_TABLES" ]; then
            echo "::error::Table count mismatch after restore!"
            exit 1
          fi
          echo "Backup verified successfully"

      - name: Remove GitHub runner IP from MySQL firewall
        if: always()
        run: |
          az mysql flexible-server firewall-rule delete \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name restrovision-mysql \
            --rule-name github-actions-runner \
            --yes 2>/dev/null || true

  sync-apps:
    name: Sync App Deployments to Backup
    runs-on: ubuntu-latest
    # Only sync apps after a deploy or manual trigger — not on daily schedule
    if: >-
      (github.event_name == 'workflow_dispatch' && github.event.inputs.sync_apps == 'true') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate --schema=packages/db/prisma/schema.prisma

      - name: Build all apps
        run: |
          echo "::group::Build API"
          npm run build:api
          echo "::endgroup::"
          echo "::group::Build Admin"
          npm run build:admin
          echo "::endgroup::"
          echo "::group::Build Super Admin"
          npm run build:super-admin
          echo "::endgroup::"
        env:
          NEXT_PUBLIC_API_URL: https://api.homeal.uk
          NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.NEXT_PUBLIC_FIREBASE_API_KEY }}
          NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN }}
          NEXT_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_PROJECT_ID }}
          NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET }}
          NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}
          NEXT_PUBLIC_FIREBASE_APP_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_APP_ID }}

      - name: Prepare API deployment
        run: |
          mkdir -p deploy-api/packages-db/prisma deploy-api/packages-shared

          # API build output
          cp -r packages/api/dist deploy-api/

          # Workspace packages (built + metadata)
          cp -r packages/db/dist deploy-api/packages-db/
          cp packages/db/package.json deploy-api/packages-db/
          cp packages/db/prisma/schema.prisma deploy-api/packages-db/prisma/
          cp -r packages/shared/dist deploy-api/packages-shared/
          cp packages/shared/package.json deploy-api/packages-shared/

          # Entry point
          printf "require('./dist/server.js');\n" > deploy-api/server.js

          # package.json with production deps + workspace file refs
          cat > deploy-api/package.json << 'PKG'
          {
            "name": "homeal-api-deploy",
            "version": "1.0.0",
            "main": "server.js",
            "scripts": {
              "start": "node server.js",
              "postinstall": "npx prisma generate --schema=packages-db/prisma/schema.prisma"
            },
            "dependencies": {
              "@homeal/db": "file:./packages-db",
              "@homeal/shared": "file:./packages-shared",
              "@azure/storage-blob": "^12.25.0",
              "@prisma/client": "^6.3.0",
              "cors": "^2.8.5",
              "express": "^4.21.0",
              "express-rate-limit": "^7.5.0",
              "firebase-admin": "^13.0.0",
              "helmet": "^8.0.0",
              "ioredis": "^5.4.0",
              "jsonwebtoken": "^9.0.2",
              "multer": "^1.4.5-lts.1",
              "prisma": "^6.3.0",
              "sharp": "^0.33.0",
              "socket.io": "^4.8.0",
              "stripe": "^17.0.0",
              "zod": "^3.24.0"
            },
            "engines": {
              "node": ">=20.0.0"
            }
          }
          PKG

          # Install production deps (Linux CI = Linux Azure)
          cd deploy-api
          npm install --production
          echo "API deploy size: $(du -sh . | cut -f1)"
          echo "node_modules: $(ls node_modules/ | wc -l) packages"
          cd ..

      - name: Prepare Admin deployment
        run: |
          mkdir -p deploy-admin
          cp -r apps/admin-web/.next/standalone/node_modules deploy-admin/
          cp apps/admin-web/.next/standalone/package.json deploy-admin/
          cp apps/admin-web/.next/standalone/apps/admin-web/server.js deploy-admin/
          cp -r apps/admin-web/.next/standalone/apps/admin-web/.next deploy-admin/.next
          cp -r apps/admin-web/.next/static deploy-admin/.next/static
          cp -r apps/admin-web/public deploy-admin/public 2>/dev/null || true
          echo "Admin deploy size: $(du -sh deploy-admin | cut -f1)"

      - name: Prepare Super Admin deployment
        run: |
          mkdir -p deploy-super-admin
          cp -r apps/super-admin/.next/standalone/node_modules deploy-super-admin/
          cp apps/super-admin/.next/standalone/package.json deploy-super-admin/
          cp apps/super-admin/.next/standalone/apps/super-admin/server.js deploy-super-admin/
          cp -r apps/super-admin/.next/standalone/apps/super-admin/.next deploy-super-admin/.next
          cp -r apps/super-admin/.next/static deploy-super-admin/.next/static
          cp -r apps/super-admin/public deploy-super-admin/public 2>/dev/null || true
          echo "Super Admin deploy size: $(du -sh deploy-super-admin | cut -f1)"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure backup apps
        run: |
          for APP in homeal-api-backup homeal-admin-backup homeal-superadmin-backup; do
            echo "Configuring $APP..."
            az webapp config appsettings set --name $APP \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --settings SCM_DO_BUILD_DURING_DEPLOYMENT=false ENABLE_ORYX_BUILD=false \
              --output none
            az webapp config set --name $APP \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --linux-fx-version "NODE|20-lts" \
              --startup-file "node server.js" \
              --output none
            # Remove any stale Docker settings
            az webapp config appsettings delete --name $APP \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --setting-names DOCKER_REGISTRY_SERVER_URL DOCKER_REGISTRY_SERVER_USERNAME DOCKER_REGISTRY_SERVER_PASSWORD 2>/dev/null || true
            echo "  Done: $APP"
          done

      - name: Start backup apps for deployment
        run: |
          for APP in homeal-api-backup homeal-admin-backup homeal-superadmin-backup; do
            az webapp start --name $APP --resource-group ${{ env.RESOURCE_GROUP }} --output none 2>/dev/null || true
          done
          echo "Backup apps started for deployment"

      - name: Create deployment zips
        run: |
          cd deploy-api && zip -qr ../api-backup.zip . && cd ..
          echo "API zip: $(du -h api-backup.zip | cut -f1)"
          cd deploy-admin && zip -qr ../admin-backup.zip . && cd ..
          echo "Admin zip: $(du -h admin-backup.zip | cut -f1)"
          cd deploy-super-admin && zip -qr ../superadmin-backup.zip . && cd ..
          echo "Super Admin zip: $(du -h superadmin-backup.zip | cut -f1)"

      - name: Deploy backup apps
        run: |
          deploy_app() {
            local APP=$1
            local ZIP=$2
            echo "=== Deploying $ZIP to $APP ==="
            echo "  Zip size: $(du -h "$ZIP" | cut -f1)"
            START=$(date +%s)

            az webapp deploy --name "$APP" \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --src-path "$ZIP" \
              --type zip \
              --async false

            END=$(date +%s)
            echo "  $APP: deployed in $((END-START))s"
          }

          deploy_app "homeal-api-backup" "api-backup.zip"
          deploy_app "homeal-admin-backup" "admin-backup.zip"
          deploy_app "homeal-superadmin-backup" "superadmin-backup.zip"

          echo ""
          echo "All backup apps synced at $(date -u)"

      - name: Ensure backup apps are stopped
        if: always()
        run: |
          for APP in homeal-api-backup homeal-admin-backup homeal-superadmin-backup; do
            az webapp stop --name $APP --resource-group ${{ env.RESOURCE_GROUP }} --output none 2>/dev/null || true
          done
          echo "Backup apps confirmed stopped"
